
MODULE Xo68x32System;
(** © ProXon/ED 3.9.94 / 22.11.98 / 7.12.00 / 12.7.01 / 23.10.01 / 9.1.02 / 23.2.02 |  *)
	(*changes:
		3.1.05, AS	USB support
		13.3.04, ED	ShowExceptionHistory
		August 1994, ED creation
	*)
	IMPORT
		SYS := SYSTEM,
		Services, Log := StdLog, Ports, TextModels, TextMappers, TextRulers, DevCommanders, DevMarkers, Strings,
		Dialog,
		XU := XdeUtilities, Errors := XdeErrors, BDI := UsbBDI332, BDIMain := UsbBDI,
		CC := Xo68x32CompConsts, OPM := Xo68x32CompM, XE := XdeErrors, CRM := Xo68x32Modules,
		RegDict := Xo68x32TrgtRegDict, ImFile := Xo68x32MemImageFile;

	CONST 
		COMPARE_IMAGE = FALSE; 

	(* constants and types *)

	CONST 
		signOnMsg = "MC68x32 Cross System  V 3.0.1 / NTB/ED 23.2.02";
		errPrefix = "System_"; 		excPrefix = "Exc_";
		kernelModName = "TobKernel";
		configText = "TargetConfig.odc"; 	configHdrText = "TargetConfigHdr.odc"; 	ramImageFileName = "RAM.tim"; 

	CONST 
		MAX_NOF_LONGS_FILL = 84;
		MAX_NOF_BYTES_WORDS_FILL = 126; 

	CONST 
		nul = 0X; ht = 9X; 	false = 0; true = 1; 	newErr = 0;
		mm = Ports.mm;
		safetyZoneSize = 4*4;
		nofRegNamesPerLine = 8; 	nofRegNamesPerPage = 15; 

	CONST  	(*OPT Structure Forms (standard types) *)
	(* structure forms *)
		sfUndef = CC.sfUndef; sfSysByte = CC.sfSysByte; sfBool = CC.sfBool; sfShChar = CC.sfShChar;
		sfByte = CC.sfByte; sfShInt = CC.sfShInt; sfInt = CC.sfInt;
		sfShReal = CC.sfShReal; sfReal = CC.sfReal;
		sfSet = CC.sfSet; sfByteSet = CC.sfByteSet; sfShSet = CC.sfShSet;
		sfString = CC.sfString;
		sfNilTyp = CC.sfNilTyp; sfNoTyp = CC.sfNoTyp;
		sfPointer = CC.sfPointer; sfProcTyp = CC.sfProcTyp; sfComp = CC.sfComp; 

	TYPE 
		Name = OPM.Name; 	ShortName = ARRAY 16 OF CHAR; 	LongName = ARRAY 64 OF CHAR;
		VarDesc = RECORD	name: LongName; textPos, adr, ind, form, size, baseType: INTEGER	END;
		ConstVarDesc = RECORD
			objMode, form, baseForm: BYTE;
			valueAdr, size: INTEGER;
			name: OPM.Name
		END;

		SystemConstEntry = RECORD	name: Name; val: INTEGER	END; 


	VAR 
		Done-: BOOLEAN;
(** previous operation successfully completed
*)
		firstErr-, nofErrors-: SHORTINT;
(** first error occured, see error list in CRErrors.Text
*)
		promCodeSize-, ramCodeSize-, romModsVarSize-, ramModsVarSize- (* targVarSize- *): INTEGER;
(** promCodeSize: size of code and constants of the set of target modules loaded to target RAM.
	ramCodeSize: size of code and constants of the set of target modules loaded to target RAM.
	targVarSize: size of all gloabal variables of the set of target modules defined by the parameter list of the Load command.
	Note: these variables may only be evaluated by the procedure  DefineMemory of the module Target. Outside of the activation of this proc, the two vars are not valid.
 *)
(* Variables *)

		itemNames: ARRAY 5 OF ARRAY 6 OF CHAR;
		formSizes: ARRAY sfComp + 1 OF SHORTINT;
		variables: ARRAY 8 OF VarDesc; nofVars: SHORTINT;
		targetState: SHORTINT;

		objRdr: OPM.ObjReader;
		referencePos: INTEGER; kernItemName: Name;

(*
	refTextModel: TextModels.Model; refTextRdr: TextModels.Reader; refTextScnr: TextMappers.Scanner;
*)
		gScnr: XU.Scanner; (* gloabal scanner *) gScnrBeg, gScnrEnd: INTEGER; 

	CONST  (* system table offsets *)
		CIsupStackOrg = 00H; 	CIstartAdr = 01H; 	CIsupStackSize = 02H; (*CImoduleTabBase=03H;*)
		CIcodeBaseRom = 04H; 	CIcodeSizeRom = 05H; 	CIcodeBaseRam = 06H; 	CIcodeSizeRam = 07H;
		CIramModsVarBase = 08H; 	CIramModsVarSize = 09H; 	CIsafetyZoneVH = 0AH;
		CIheapBase = 0CH; 	CIheapSize = 0DH; 	CIsafetyZoneHUS = 0EH;
		CIuserStackOrg = 10H; 	CIuserStackSize = 11H; 	CIsafetyZoneUSSS = 12H; 	CIsafetyZoneSSTop = 13H;
		CIsafetyZoneCode = 14H; 	(* 4 longs for safety zone codes *)
		CImaxNofModules = 1EH; 	CInofModules = 1FH;
		CIfirstModule = 20H;
(*R 971127
	CItagFcs=LEN(sysTab)-1;
*) 
	VAR  (* target parameters, extracted from TobKernel and/or calculated by Xo68x32System *)
		systemParDefined, CwatchdogEnab: BOOLEAN;

(*R 971127
	CromBase, CromSize, CramBase, CramSize, CperiphBase, CperiphSize: INTEGER;
*)
		CromBase, CromSize, CramBase, CramSize: INTEGER;
		VcommandAdr: INTEGER; 	(* offset of system variable Vcommand in module TobKernel *) 

	VAR 
		kernelMemDeviceId: SHORTINT;
		configT: TextModels.Model; configTextForm: TextMappers.Formatter; 

	VAR  (* targget/host system parameters *)
(*R 971127
	sysTabAdr: INTEGER; sysTab: ARRAY (20H + (3*CmaxNofModules + 3 + 1)) OF INTEGER;
*)
		sysTabAdr, sysTabSize, maxNofModules, vItagFcs: INTEGER; sysTab: POINTER TO ARRAY OF INTEGER;
		sysConsts: ARRAY 32 OF SystemConstEntry; nofSysConsts: INTEGER;
		anyCodeInReadOnly, anyCodeInRam: BOOLEAN;
		tmpTargetInDebugMode: BOOLEAN; 

	VAR 
	Fcs: PROCEDURE (begin, end: INTEGER): SHORTINT; 

	VAR 
		addrList*, dataList*: ARRAY 10000 OF INTEGER;
		maxDataListIndex*: INTEGER; 


	PROCEDURE Error (errNr: SHORTINT); 
	BEGIN
		IF Done THEN	firstErr := errNr; 	Done := FALSE	END; 	INC(nofErrors);
		XE.Error("", errPrefix, errNr, TRUE)
	END Error; 

	(*
		PROCEDURE SyntaxErrorLn (pos: INTEGER; errNr: SHORTINT); 
	BEGIN
		Error(errNr);	Log.Tab; Log.String("pos  "); Log.Int(pos); Log.Ln
	END SyntaxErrorLn; 

	*)
	PROCEDURE SyntaxErrorAtScnrPos (pos: INTEGER; errNr: SHORTINT); 
		VAR errMsg: XU.String64;
	BEGIN
		IF Done THEN
			Strings.IntToString(errNr, errMsg);
			XE.GetErrorCommentByName(NIL, errPrefix + errMsg, errMsg);
			DevMarkers.Insert(gScnr.Base(), pos, DevMarkers.dir.NewMsg(errMsg));
			gScnr.SetPos(gScnr.Pos() + 1);
			Error(errNr); Log.String(" (lokate marker)"); Log.Ln
		END
	END SyntaxErrorAtScnrPos; 

	PROCEDURE LogLine (s: ARRAY OF CHAR); 
	BEGIN
		Log.String("Xo68x32System: "); Log.Tab; Log.String(s$); Log.Ln
	END LogLine; 

	PROCEDURE LogHex (val: INTEGER); 
	BEGIN
		Log.Char('0'); Log.IntForm(val MOD 100000000L, Log.hexadecimal, 1, ' ', Log.hideBase); Log.Char('H')
	END LogHex; 

	PROCEDURE LogCmdr; 
	BEGIN
		Log.View(DevCommanders.dir.New())
	END LogCmdr; 

	PROCEDURE LogCmdrEnd; 
	BEGIN
		Log.View(DevCommanders.dir.NewEnd())
	END LogCmdrEnd; 

	PROCEDURE LogXo68x32SystemCmd (IN cmd: ARRAY OF CHAR); 
	BEGIN
		Log.Char(' '); LogCmdr; Log.String("Xo68x32System." + cmd)
	END LogXo68x32SystemCmd; 


	PROCEDURE ConnectGlobalScannerToCmdParams; 
		VAR	parText: TextModels.Model;
	BEGIN
		XU.GetTextModel("@!", parText, gScnrBeg, gScnrEnd);
		gScnr.ConnectTo(parText);
		gScnr.SetOpts({XU.soReturnQualIdents, XU.soReturnViews});
		gScnr.SetPos(gScnrBeg)
	END ConnectGlobalScannerToCmdParams; 


	PROCEDURE GetTargetStateAndBreak;
	BEGIN
		tmpTargetInDebugMode := BDI.isTargetInDebugMode();
		BDIMain.ConnectDevice;
		IF ~BDI.isTargetInDebugMode() THEN
			IF ~BDI.isFreezeAsserted () THEN
				BDI.break_
			END
		END
	END GetTargetStateAndBreak;
	

	PROCEDURE TurnTargetToPrevState; 
	BEGIN
		IF BDI.isTargetInDebugMode () & ~tmpTargetInDebugMode THEN	BDI.go	END
	END TurnTargetToPrevState; 

	PROCEDURE ShowTargetState; 
	BEGIN
		IF BDI.isTargetInDebugMode() THEN
			Log.String("target stopped"); LogXo68x32SystemCmd("TargetGo ?"); Log.Ln
		ELSE
			Log.String("target running"); LogXo68x32SystemCmd("TargetBreak ?"); Log.Ln
		END
	END ShowTargetState; 

	PROCEDURE ObjRead (OUT byte: BYTE); 
	BEGIN
		OPM.ReadByte(objRdr, byte)
	END ObjRead; 

	PROCEDURE ObjReadInt (OUT val: INTEGER); 
	BEGIN
		OPM.ReadInt(objRdr, val)
	END ObjReadInt; 

	PROCEDURE RefOpen (IN modName: OPM.Name); 
		VAR tag, compVers: BYTE;
	BEGIN
		Done := TRUE;
		objRdr := OPM.NewObjReader(modName, NIL);
		IF objRdr = NIL THEN
			Error(11)
		ELSE
			ObjRead(tag); IF tag # CC.tagObjFile THEN
				Error(newErr)
			ELSE
				ObjRead(compVers); ObjReadInt(referencePos);
				objRdr.SetPos(referencePos);
				ObjRead(tag); IF tag # CC.tagReference THEN	Error(2)	END
			END
		END
	END RefOpen; 

	PROCEDURE RefRead (OUT byte: BYTE); 
	BEGIN
		OPM.ReadByte(objRdr, byte)
	END RefRead; 

	PROCEDURE RefReadNum (OUT val: INTEGER); 
	BEGIN
		OPM.ReadNum(objRdr, val)
	END RefReadNum; 

	PROCEDURE RefReadInt (OUT val: INTEGER); 
	BEGIN
		OPM.ReadNum(objRdr, val)
	END RefReadInt; 

	PROCEDURE RefReadNameVis (OUT str: ARRAY OF CHAR; OUT visibility: BYTE); 
	BEGIN
		OPM.RefRNameVis(objRdr, str, visibility)
	END RefReadNameVis; 

	PROCEDURE SelectGlobItem (objMode: INTEGER; IN objName: ARRAY OF CHAR; OUT obj: ConstVarDesc); 
		VAR
			valueAdr, size: INTEGER; oMode, form, baseForm: BYTE;
			name: OPM.Name;
			tag, vis: BYTE; 	found: BOOLEAN;
	BEGIN
		objRdr.SetPos(referencePos);
		ObjRead(tag); IF tag # CC.tagReference THEN
			Error(2)
		ELSE
			RefRead(tag);
			IF tag # CC.tagRefBlock THEN
				Error(3)
			ELSE
				RefReadNum(valueAdr); RefReadNameVis(name, vis); (* skip module body *)
				REPEAT
					RefRead(oMode); 	RefReadNameVis(name, vis); 	RefReadInt(valueAdr);
					RefReadInt(size); 	RefRead(form); 	RefRead(baseForm);
					found := ((objMode = oMode) & (objName = name))
				UNTIL found OR (objMode = CC.tagRefBlock) OR objRdr.eof;
				IF found THEN
					obj.name := name;
					obj.objMode := oMode; obj.form := form; obj.baseForm := baseForm; obj.size := size;
					IF objMode = CC.omVar THEN	DEC(valueAdr, OPM.maxCodeSize)	END;
					obj.valueAdr := valueAdr;
				ELSE
					obj.name := "";
					obj.objMode := 0; obj.form := CC.sfUndef; obj.baseForm := CC.sfUndef;
					obj.valueAdr := 0; obj.size := 0
				END
			END
		END
	END SelectGlobItem; 


	PROCEDURE TKernelRefOpen * ; 
(** Opens the file TobKernel reference part of the object file
*)
		VAR	c0, c1: CHAR;
	BEGIN
		referencePos := 0; kernItemName := ""; 	RefOpen(kernelModName)
	END TKernelRefOpen; 

	PROCEDURE TKernelConst * (IN name: ARRAY OF CHAR): INTEGER; 
(** Returns the value of any global constant of module TobKernel. name is the const name without the module name.
	Note: open the file with TobKernelRefOpen and than fetch constants in alphabetic order to speed up.
	Exmpl:	ramSize := TobKernelConst("CramSize");
*)
		VAR	cv: ConstVarDesc;
	BEGIN
		SelectGlobItem(CC.omConst, name, cv); (* PrintCV(cv); Log.Ln; *)
		IF cv.objMode = 0 THEN	Error(13)	ELSE		kernItemName := cv.name$	END;
		RETURN cv.valueAdr
	END TKernelConst; 


	PROCEDURE TKernelVarOffset (name: ARRAY OF CHAR): INTEGER; 
		VAR	cv: ConstVarDesc;
		VAR val: INTEGER; c0, c1: CHAR;
	BEGIN
		SelectGlobItem(CC.omVar, name, cv); (* PrintCV(cv); Log.Ln; *)
		IF cv.objMode = 0 THEN	Error(14)	ELSE		kernItemName := cv.name$	END;
		RETURN cv.valueAdr
	END TKernelVarOffset; 


	PROCEDURE CreateSystemTab (len: INTEGER); 
		VAR i: INTEGER;
	BEGIN
		Log.String("CreateSystemTab"); Log.Ln;
		NEW(sysTab, len); vItagFcs := len - 1;
		systemParDefined := FALSE;
		FOR i := 0 TO LEN(sysTab^) - 1 DO	sysTab[i] := 0	END;
		sysTab[CIsafetyZoneCode] := 7F7F5E5EH; 	sysTab[CIsafetyZoneCode + 1] := 4D4D3C3CH;
		sysTab[CIsafetyZoneCode + 2] := 2B2B1A1AH; 	sysTab[CIsafetyZoneCode + 3] := 55554AB3H
	END CreateSystemTab; 

	PROCEDURE GetSystemConstants; 
(* gets the system constants from TobKernel.Ref and creates the system tab *)
		VAR n, v, offset: INTEGER;
	BEGIN
		Done := TRUE;
		TKernelRefOpen;
(*R 971127*)
		n := TKernelConst("COtagFcs");
		maxNofModules := TKernelConst("CmaxNofModules");
		sysTabSize := TKernelConst("CsysTabSize");

		IF sysTabSize # (CIfirstModule + 3 * maxNofModules + 3 + 1) * 4 THEN	Error(15)	END;
		IF Done THEN
			CreateSystemTab(sysTabSize DIV 4);
			IF n # (LEN(sysTab^) - 1) * 4 THEN	Error(15)	END
		END;

		IF Done THEN
			n := 0;
			WHILE Done & (n < nofSysConsts) DO
				v := TKernelConst(sysConsts[n].name); 	offset := sysConsts[n].val;
				IF offset >= 0 THEN
					IF v # offset THEN
						Error(16); Log.Tab; Log.String("const name "); Log.String(sysConsts[n].name$); Log.Ln
					END
				ELSE
					sysTab[ABS(offset)] := v
				END;
				INC(n);
			END;

(*R 971127
		CperiphBase :=  TKernelConst("CperiphBase");	CperiphSize :=  TKernelConst("CperiphSize");
*)
			CramBase := TKernelConst("CramBase"); 	CramSize := TKernelConst("CramSize");
			CromBase := TKernelConst("CromBase"); 	CromSize := TKernelConst("CromSize");
			CwatchdogEnab := TKernelConst("CwatchdogEnab") # false;

			VcommandAdr := TKernelVarOffset("Vcommand"); (* offset by this time, inc in Xo68x32System.Load *)
		END
	END GetSystemConstants; 

	PROCEDURE InsertSysConst (name: ARRAY OF CHAR; val: INTEGER); 
		VAR n: INTEGER;
	BEGIN
		n := nofSysConsts - 1;
		ASSERT(nofSysConsts < LEN(sysConsts), 99);
		WHILE (n >= 0) & (name < sysConsts[n].name) DO
			sysConsts[n + 1] := sysConsts[n]; DEC(n);
		END;
		INC(n);
		ASSERT(name # sysConsts[n].name, 99);
		sysConsts[n].name := name$; sysConsts[n].val := val;
		INC(nofSysConsts)
	END InsertSysConst; 

	PROCEDURE SystemConstantsSetUp; 
(* gets the system constants from TKernel.Ref *)
	BEGIN
(*R 971127
	ClearSystemTab;
*)

(* system table offsets to be checked *)
		nofSysConsts := 0;
		InsertSysConst("COsupStackOrg", 4 * CIsupStackOrg); 	(* 00H *)
		InsertSysConst("COstartAdr", 4 * CIstartAdr);
		InsertSysConst("COsupStackSize", 4 * CIsupStackSize);

		InsertSysConst("COcodeBaseRom", 4 * CIcodeBaseRom); 	(* 04H *)
		InsertSysConst("COcodeSizeRom", 4 * CIcodeSizeRom);
		InsertSysConst("COcodeBaseRam", 4 * CIcodeBaseRam);
		InsertSysConst("COcodeSizeRam", 4 * CIcodeSizeRam);

		InsertSysConst("COramModsVarBase", 4 * CIramModsVarBase); 	(* 08H *)
		InsertSysConst("COramModsVarSize", 4 * CIramModsVarSize);
		InsertSysConst("COsafetyZoneVH", 4 * CIsafetyZoneVH);

		InsertSysConst("COheapBase", 4 * CIheapBase); 	(* 0CH *)
		InsertSysConst("COheapSize", 4 * CIheapSize);
		InsertSysConst("COsafetyZoneHUS", 4 * CIsafetyZoneHUS);

		InsertSysConst("COuserStackOrg", 4 * CIuserStackOrg); 	(* 10H *)
		InsertSysConst("COuserStackSize", 4 * CIuserStackSize);
		InsertSysConst("COsafetyZoneUSSS", 4 * CIsafetyZoneUSSS);
		InsertSysConst("COsafetyZoneSSTop", 4 * CIsafetyZoneSSTop);

		InsertSysConst("COsafetyZoneCode", 4 * CIsafetyZoneCode); 	(* 14H .. 17H *)

		InsertSysConst("COmaxNofModules", 4 * CImaxNofModules); 		(* 1EH *)
		InsertSysConst("COnofModules", 4 * CInofModules); 		(* 1FH *)
		InsertSysConst("COfirstModule", 4 * CIfirstModule); 	(* 20H *)
(*R 971127
	InsertSysConst("COtagFcs", 4*CItagFcs);	(* 20H *)
*)

(* system consts to be fetched *)
		InsertSysConst("CsupStackSize", - CIsupStackSize);
		InsertSysConst("CuserStackSize", - CIuserStackSize);
		InsertSysConst("CmaxNofModules", - CImaxNofModules)
	END SystemConstantsSetUp; 


	PROCEDURE ShowSysConsts * ; 
(** Shows system constants in System.Log.	(for developpers only)
*)
		VAR n: INTEGER;
	BEGIN
		Log.Ln; Log.String("System Constants:"); Log.Ln; Log.Tab; Log.String("system table offsets"); Log.Ln;
		n := 0;
		WHILE n < nofSysConsts DO
			Log.Tab; Log.Tab; Log.String(sysConsts[n].name$); Log.Tab; LogHex(sysConsts[n].val); Log.Ln;
			INC(n);
		END;
		Log.Ln; Log.Tab; Log.String("system parameters"); Log.Ln;
		Log.Ln; Log.Tab; Log.Tab; Log.String("CromBase"); Log.Tab; LogHex(CromBase);
		Log.Ln; Log.Tab; Log.Tab; Log.String("CromSize"); Log.Tab; LogHex(CromSize);
		Log.Ln; Log.Tab; Log.Tab; Log.String("CramBase"); Log.Tab; LogHex(CramBase);
		Log.Ln; Log.Tab; Log.Tab; Log.String("CramSize"); Log.Tab; LogHex(CramSize);
(*R 971127
	Log.Ln; Log.Tab; Log.Tab; Log.String("CperiphBase"); Log.Tab;LogHex(CperiphBase, 0);
	Log.Ln; Log.Tab; Log.Tab; Log.String("CperiphSize"); Log.Tab;LogHex(CperiphSize, 0);
*)
		Log.Ln; Log.Tab; Log.Tab; Log.String("CcodeInReadOnlyMem"); Log.Tab; Log.Bool(anyCodeInReadOnly);
		Log.Ln; Log.Tab; Log.Tab; Log.String("CwatchdogEnab"); Log.Tab; Log.Bool(CwatchdogEnab)
	END ShowSysConsts; 

	PROCEDURE ShowSystemTable * ; 
(** Shows the content of the system table in System.Log
*)
		VAR m, n, ln: INTEGER; name: Name;
	BEGIN
		Log.Ln; Log.String("System Table"); Log.Ln;
		ln := 0;
		IF ~systemParDefined THEN
			Log.Tab; Log.String("not yet defined (do first 'Xo68x32System.Load' or 'Xo68x32System.GenPromFile'"); Log.Ln;
			RETURN
		END;
		n := 0;
		WHILE n < 20H DO
			m := 0;
			WHILE (m < nofSysConsts) & (sysConsts[m].val # 4 * n) DO	INC(m)	END;
			IF m < nofSysConsts THEN
				name := sysConsts[m].name; name[0] := ' '; name[1] := ' ';
				Log.Tab; LogHex(n); Log.String(name$); Log.Char(":"); Log.Tab; LogHex(sysTab[n]);
				IF n = CIsafetyZoneCode THEN
					Log.Tab; LogHex(sysTab[CIsafetyZoneCode + 1]);
					Log.Tab; LogHex(sysTab[CIsafetyZoneCode + 2]);
					Log.Tab; LogHex(sysTab[CIsafetyZoneCode + 3])
				END;
				Log.Ln; ln := 0
			ELSE
				IF ln = 0 THEN	Log.Ln	END; INC(ln);
			END;
			INC(n);
		END; Log.Ln;
		m := 0; 	n := CIfirstModule;
		WHILE (m < CRM.nofModules) DO
			LogHex(n); Log.Tab; Log.String("code begin"); Log.Tab; Log.Int(m); Log.Char(":");
			Log.Tab; LogHex(sysTab[n]); Log.Ln; INC(n);
			LogHex(n); Log.Tab; Log.String("code limit  "); Log.Tab; Log.Int(m); Log.Char(":");
			Log.Tab; LogHex(sysTab[n]); Log.Ln; INC(n);
			LogHex(n); Log.Tab; Log.String("body          "); Log.Int(m); Log.Tab; Log.Char(":");
			Log.Tab; LogHex(sysTab[n]); Log.Ln; INC(n);
			INC(m); Log.Ln
		END
(*R 971127
	LogHex(LEN(sysTab^)-1, 3); Log.Tab; Log.String("tag,fcs:"); Log.Tab; LogHex(sysTab[LEN(sysTab^)-1], 0); Log.Ln;
*)
	END ShowSystemTable; 


	PROCEDURE InsertVar (name: ARRAY OF CHAR; pos: INTEGER); 
		VAR n: INTEGER;
	BEGIN
		IF nofVars < LEN(variables) THEN
			n := nofVars - 1;
			WHILE (n >= 0) & (name < variables[n].name) DO
				variables[n + 1] := variables[n]; DEC(n)
			END;
			INC(n);
			variables[n].name := name$; variables[n].textPos := pos; variables[n].adr := 0;
			variables[n].ind := 0; variables[n].form := 0; variables[n].size := 0; variables[n].baseType := 0;
			INC(nofVars)
		END
	END InsertVar; 

	PROCEDURE PrintVariable (n: SHORTINT); 
	BEGIN
		Log.Ln; Log.String("Variable["); Log.Int(n); Log.String("]: ");
		Log.String("name="); Log.String(variables[n].name$);
		Log.String(", textPos "); Log.Int(variables[n].textPos);
		Log.Ln; Log.Tab; Log.String("adr="); LogHex(variables[n].adr);
		Log.String(", ind="); Log.Int(variables[n].ind);
		Log.String(", form="); Log.Int(variables[n].form);
		Log.String(", size="); Log.Int(variables[n].size);
		Log.String(", baseType="); Log.Int(variables[n].baseType); Log.Ln
	END PrintVariable; 

	(*
	PROCEDURE PrintVars; 
	VAR n: SHORTINT;
	BEGIN
		n := 0;	WHILE n < nofVars DO	PrintVariable(n);	INC(n)	END
	END PrintVars; 
	*)
	PROCEDURE WriteRegToLog (regName: ARRAY OF CHAR; VAR validName: BOOLEAN); 
		VAR
			val: INTEGER; 	write: RegDict.WriteProc; 	n: SHORTINT;
	BEGIN
		Log.String(regName$); 	Log.String(" = ");
		RegDict.SelectReg(regName, validName);
		IF ~validName THEN	SyntaxErrorAtScnrPos(gScnr.Pos(), 0); RETURN	END;
		write := RegDict.RegWriteProc(); 	n := RegDict.RegSize();

		CASE RegDict.RegType() OF
		| RegDict.UserReg: 	val := BDI.readUserReg(RegDict.RegCode());
		| RegDict.SysReg: 	 val := BDI.readSysReg(  RegDict.RegCode());
		| RegDict.CtrlReg: 	 val := BDI.readMem(  RegDict.RegCode(), n);
		ELSE
			Error(1)
		END;
		CASE n OF	|1: val := val MOD 100H; 	|2: val := val MOD 10000H	ELSE	END;
		LogHex(val);
		Log.String("(*" ); Log.Int(val); 	Log.String("*)"); Log.Ln
	END WriteRegToLog; 

	PROCEDURE OutNum (hexVal, decVal, cardinal: INTEGER); 
	BEGIN
		Log.String("  "); LogHex(hexVal); Log.String("(*"); Log.Int(decVal);
		IF cardinal # 0 THEN	Log.String(" | "); Log.Int(cardinal)	END;
		Log.String("*)")
	END OutNum; 

	PROCEDURE OutItem (val: INTEGER; form: INTEGER); 
		VAR	card: INTEGER; real: SHORTREAL; int: SHORTINT; short: BYTE; c: CHAR;
	BEGIN
		card := 0;
		CASE form OF
		|sfBool:
			val := val MOD 100H; Log.String("  "); LogHex(val);
			IF val = 0 THEN Log.String("(*FALSE*)") ELSE Log.String("(*TRUE*)") END;
		|sfShChar:
			c := SHORT(CHR(val));
			IF (c >= ' ') & (c <= '~') THEN	Log.Char(c)	ELSE	Log.Char('.')	END;

		|sfByte:
			short := SHORT(SHORT(val)); 	IF short < 0 THEN card := LONG(short) + 100H END;
			OutNum(val MOD 100H, short, card)
		|sfShInt:
			int := SHORT(val); 	IF int < 0 THEN card := LONG(int) + 10000H END;
			OutNum(val MOD 10000H, int, card)
		|sfInt: 	OutNum(val, val, 0)
		|sfShReal:
			Log.String("  "); real := SYS.VAL(SHORTREAL, val); Log.Real(real);
			Log.String("(*"); LogHex(val); Log.String("*)")
		ELSE
			Log.String("  "); LogHex(val)
		END
	END OutItem; 

	PROCEDURE ReadMemLocs (memAddr: INTEGER; itemSize, len, form: INTEGER); 
		VAR
			memData, m, dataLength, recLength, i: INTEGER; itemsPerLine: SHORTINT;
			data: ARRAY MAX_NOF_LONGS_FILL OF INTEGER;
	BEGIN
	(*
	Log.String("ReadMemLocs: addr="); LogHex(memAddr); Log.String(", itemSize="); LogHex(itemSize);
	Log.String(", len="); LogHex(len); Log.String(", form="); LogHex(form); Log.Ln;
	*)
		itemsPerLine := 4; 	IF itemSize = 1 THEN	itemsPerLine := 8	END;
		IF form = sfShChar THEN	itemsPerLine := 256	END;
		m := 0; IF len > 256 THEN	len := 256	END;
		LOOP
			IF m = 0 THEN
				memData := BDI.readMem(memAddr, itemSize);
				LogHex(memAddr); Log.Char(':'); IF form = sfShChar THEN	Log.Tab	END;
				OutItem(memData, form); m := itemsPerLine;
				recLength := 1;
			ELSE
				dataLength := MAX_NOF_LONGS_FILL;
				IF len < MAX_NOF_LONGS_FILL THEN
					dataLength := len
				END;
(* FIXME: LEN(data) may be too long for the last dump *)
				BDI.dumpMem(LEN(data), data, recLength);
				(*
				Log.Ln; Log.String("Dump: recLength: "); Log.Int(recLength);
				Log.String(", len: "); Log.Int(len); Log.Ln;
				*)
				FOR i := 0 TO recLength - 1 DO
					OutItem(data[i], form); Log.Ln;
				END
			END;
			IF ~BDI.Done THEN
				Error(41); 	EXIT
			END;
			INC(memAddr, LONG(itemSize) * recLength); DEC(len, recLength); IF len <= 0 THEN	EXIT	END;
			DEC(m); 	IF m = 0 THEN	LogCmdrEnd; Log.Ln	END
		END;
		LogCmdrEnd; Log.Ln
	END ReadMemLocs; 

	PROCEDURE ReadVariables; 
		VAR form, itemSize, len, n: INTEGER;
	BEGIN
		GetTargetStateAndBreak; n := 0;
		WHILE n < nofVars DO
			form := variables[n].form;
			IF form = sfComp THEN	form := variables[n].baseType	END;
			itemSize := formSizes[form];
			len := variables[n].size DIV itemSize;
			Log.String("Var: "); Log.String(variables[n].name$); Log.Ln;
			Log.Tab; ReadMemLocs(variables[n].adr, itemSize, len, form);
			INC(n)
		END;
		TurnTargetToPrevState; ShowTargetState
	END ReadVariables; 

	PROCEDURE ReadMem (form: INTEGER); 
		VAR	c: CHAR; 	ch: CHAR; memAddr: INTEGER; 	len, itemSize: INTEGER;
	BEGIN
		ConnectGlobalScannerToCmdParams;
		IF ~gScnr.done THEN	Error(22); RETURN	END;
		gScnr.SetOpts({XU.soSkipComments, XU.soScanComments, XU.soReturnViews});

		itemSize := formSizes[form];
		gScnr.Int(memAddr); 	IF ~gScnr.done THEN	SyntaxErrorAtScnrPos(gScnr.Pos(), 21); 	RETURN	END;
		gScnr.Char(ch); c := SHORT(ch);
		IF ~gScnr.done OR (c # ':') THEN	SyntaxErrorAtScnrPos(gScnr.Pos() - 1, 05); 	RETURN	END;
		gScnr.Int(len); 	IF ~gScnr.done THEN	SyntaxErrorAtScnrPos(gScnr.Pos(), 23); 	RETURN	END;

		GetTargetStateAndBreak;
		ReadMemLocs(memAddr, itemSize, len, form);
		TurnTargetToPrevState; ShowTargetState
	END ReadMem; 


	PROCEDURE TargetInitSuccessful * (done: BOOLEAN); 
(** Indicates successful initialisation of the target, called by proc Init in module Target.
*)
	BEGIN
		Done := done;
	END TargetInitSuccessful; 

	PROCEDURE ReadVar * ; 
(** parameters:	varName {varName} "¿¿E".		varName = moduleName "." variableName.
	Shows the content of the variables listed in the parameter list. Var name need to be qualified by the module name.
*)
		VAR
			mod, prevMod: CRM.TargetModule;
			len, dotPos, n, timeInt, pos: INTEGER;
			name: LongName; modName, varName: Name; tempName: ARRAY 32 OF CHAR;
			refTextModel: TextModels.Model; c0, c1: CHAR;
			name2: ARRAY 64 OF CHAR;
			cv: ConstVarDesc;
	BEGIN
		Done := TRUE; nofVars := 0; c1 := nul;
		ConnectGlobalScannerToCmdParams; 	IF ~gScnr.done THEN	Error(22); RETURN	END;
		gScnr.SetOpts({XU.soReturnQualIdents, XU.soReturnViews, XU.soSkipComments, XU.soScanComments});

		IF gScnr.Next() = XU.stInt THEN	gScnr.Int(timeInt)	END;
		pos := gScnr.Pos(); gScnr.Ident(name2); name := SHORT(name2$);
		WHILE gScnr.done & (nofVars < LEN(variables)) DO
			InsertVar(name, pos); 	pos := gScnr.Pos(); gScnr.Ident(name2); name := SHORT(name2$);
		END;
		IF nofVars = 0 THEN	SyntaxErrorAtScnrPos(pos, 11); RETURN	END;
		IF gScnr.done THEN	Error(19)	END;

		n := 0; prevMod := NIL;
		LOOP
			name := variables[n].name; pos := variables[n].textPos;
			len := LEN(name$); 	Strings.Find(name$, ".", 0, dotPos);
			IF (len = 0) OR (dotPos <= 0) THEN	SyntaxErrorAtScnrPos(pos, 24); 	EXIT	END;
			Strings.Extract(name$, 0, dotPos, modName);

			mod := CRM.ThisLoadedModule(modName);
			IF mod = NIL THEN	SyntaxErrorAtScnrPos(pos, 25); 	EXIT	END;

			IF mod # prevMod THEN
				prevMod := mod;
				referencePos := 0; RefOpen(modName);
				IF referencePos = 0 THEN	SyntaxErrorAtScnrPos(pos, 11); 	EXIT	END;
(*
Log.String("Sys:ReadVar "); Log.String(name); Log.String(", modName: "); Log.String(modName);

			XU.GetRefModel(modName$, refTextModel);
			IF refTextModel = NIL THEN	SyntaxErrorAtScnrPos(pos, 11);	EXIT	END;

			gScnr.ConnectTo(refTextModel); gScnr.Scan; c1 := nul;
			REPEAT	c0 := c1; gScnr.Char(c1)	UNTIL ~gScnr.done OR (c0 = '>') & (c1 = 'M');
			IF ~gScnr.done THEN	SyntaxErrorAtScnrPos(pos, 12);	EXIT	END;
*)
			END;

			Strings.Extract(name$, dotPos + 1, len - dotPos - 1, varName);
			SelectGlobItem(CC.omVar, varName, cv);
			IF cv.objMode = CC.omUndef THEN	SyntaxErrorAtScnrPos(pos, 14); 	EXIT	END;
(*
Log.String(", varName: "); Log.String(varName); Log.String(", modName"); Log.Ln;

		REPEAT
			REPEAT	c0 := c1; gScnr.Char(c1)	UNTIL ~gScnr.done OR (c0 = '>') & (c1 = 'V');
			gScnr.Ident(name2); name := SHORT(name2$);
		UNTIL ~gScnr.done OR (name = varName);

Log.Tab; Log.String("name: ");Log.String(name); Log.Ln;
Log.Tab; Log.String("adr0: "); LogHex(cv.valueAdr); Log.Ln;
Log.Tab; Log.String("VarBase: "); LogHex(CRM.VarBase(mod)); Log.Ln;
Log.Tab; Log.String("VarSize: "); LogHex(CRM.VarSize(mod)); Log.Ln;
*)

			variables[n].ind := CC.omVar;
			variables[n].adr := cv.valueAdr + CRM.VarBase(mod);
			variables[n].form := cv.form;
			variables[n].size := cv.size;
			variables[n].baseType := cv.baseForm;

(*
Log.Tab; Log.String("oMode: "); LogHex(variables[n].ind); Log.Ln;
Log.Tab; Log.String("form: "); LogHex(variables[n].form); Log.Ln;
Log.Tab; Log.String("baseForm: "); LogHex(variables[n].baseType); Log.Ln;
Log.Tab; Log.String("size: "); LogHex(variables[n].size); Log.Ln;
Log.Tab; Log.String("adr: "); LogHex(variables[n].adr); Log.Ln;

		gScnr.Int(variables[n].ind);	gScnr.Int(variables[n].adr);	INC(variables[n].adr, CRM.VarBase(mod));
		gScnr.Int(variables[n].form);	gScnr.Int(variables[n].size);	gScnr.Int(variables[n].baseType);
		IF ~gScnr.done THEN	SyntaxErrorLn(pos, 12);	EXIT	END;
*)

			INC(n); 	IF n >= nofVars THEN	EXIT	END;
		END;
		IF Done THEN	ReadVariables	END;
	END ReadVar; 

	PROCEDURE LogExceptionsHead; 
		VAR	ruler: TextRulers.Ruler;
	BEGIN
		ruler := TextRulers.dir.New(NIL);
(*
		TextRulers.SetFirst(ruler, 8*mm); TextRulers.SetLeft(ruler, 12*mm);
	exc#	format		vectNr	vectOffset	SR	PC (addr)	 Module[pcOffset]
	 1	02H		06H	018H	02700H	01018CAH 	To68x32Heap[0932H]
	*)
		TextRulers.AddTab(ruler, 8 * mm); 	TextRulers.MakeRightTab(ruler); 	(*exc#*)
		TextRulers.AddTab(ruler, 20 * mm); 	TextRulers.MakeRightTab(ruler); 	(*format*)
		TextRulers.AddTab(ruler, 24 * mm); 	(*exception comment from Xde\Docu\Errors*)
		TextRulers.AddTab(ruler, 34 * mm); 	TextRulers.MakeRightTab(ruler); 	(*evectNr*)
		TextRulers.AddTab(ruler, 50 * mm); 	TextRulers.MakeRightTab(ruler); 	(*vectOffset*)
		TextRulers.AddTab(ruler, 66 * mm); 	TextRulers.MakeRightTab(ruler); 	(*SR*)
		TextRulers.AddTab(ruler, 90 * mm); 	TextRulers.MakeRightTab(ruler); 	(*PC (addr)*)
		TextRulers.AddTab(ruler, 92 * mm); 	(*Module[pcOffset]*)
		Log.View(ruler);
		Log.Tab; Log.String("exc#"); 	Log.Tab; Log.String("format");
		Log.Tab; Log.Tab; Log.String("vectNr"); 	Log.Tab; Log.String("vectOffset"); 	Log.Tab; Log.String("SR");
		Log.Tab; Log.String("PC (addr)"); 	Log.Tab; Log.String("Module[pcOffset]"); 	Log.Ln;
	END LogExceptionsHead; 

	PROCEDURE LogDefaultRuler; 
		VAR	ruler: TextRulers.Ruler;
	BEGIN
		ruler := TextRulers.dir.New(NIL); 	Log.View(ruler)
	END LogDefaultRuler; 


	PROCEDURE ShowExceptionHistory * ; 
(** parameters:	varName {varName} "¿¿E".		varName = moduleName "." variableName.
	Shows the content of the variables listed in the parameter list. Var name need to be qualified by the module name.
*)
		VAR
			mod: CRM.TargetModule;
			len, dotPos, n, timeInt, intVal, vectNr: INTEGER;
			mwordsPC: ARRAY 4 OF INTEGER; (*mwordsPC[0] = M[pc], mwordsPC[1] = M[pc-2], ... mwordsPC[3] = M[pc-6]*)
			name: LongName; modName, varName: Name; tempName: ARRAY 32 OF CHAR;
			refTextModel: TextModels.Model; c0, c1: CHAR;
			cv: ConstVarDesc;
	(*---- Kernel Variables*)
			nofUnexpInt, trInd, stAdr: INTEGER; 	(* nofUnexpInt: total number, trInd: trace index (of last int) *)
			pcs: ARRAY 16 OF INTEGER; 	(* address at which the unexpected int occured *)
			status: ARRAY 16 OF INTEGER; 	(* status words *)
			vect: ARRAY 16 OF INTEGER; 	(* interrupt type (4 bits) and vector number 12 bits *)
			buff: ARRAY 16 OF INTEGER;

			PROCEDURE ReadMemLocs (IN varName: ARRAY OF CHAR; OUT len: INTEGER;
		OUT ints: ARRAY OF INTEGER);
			VAR
				memAddr, memData, m: INTEGER; 	itemSize, form, maxLen: INTEGER;
		BEGIN
			SelectGlobItem(CC.omVar, varName, cv);
			IF cv.objMode = CC.omUndef THEN
				Error(14)
			ELSE
				memAddr := cv.valueAdr + CRM.VarBase(mod);
				form := cv.form;
				IF form = sfComp THEN	form := cv.baseForm	END;
				itemSize := formSizes[form];
				len := cv.size DIV itemSize;
	(*
	Log.String("Var: "); Log.String(cv.name$); Log.Ln;
	Log.String("addr="); LogHex(memAddr); Log.String(", itemSize="); LogHex(itemSize);
	Log.String(", len="); LogHex(len); Log.String(", form="); LogHex(form); Log.Ln;
	*)
				GetTargetStateAndBreak;
				memData := BDI.readMem(memAddr, itemSize); 	ints[0] := memData;
				m := 1; 	maxLen := MIN(len, LEN(ints));
				WHILE m < maxLen DO
					HALT(35);
				(* BDI.DumpMem(memData, itemSize); (*OutItem(memData, form);*)	ints[m] := memData; *)
					INC(m)
				END;
				TurnTargetToPrevState
			END
		END ReadMemLocs;


		PROCEDURE LogLocation (pc: INTEGER);
			VAR
				mod: CRM.TargetModule; 	base: INTEGER;
				name: OPM.LongName;
		BEGIN
			mod := CRM.FirstModule();
			LOOP
				IF mod = NIL THEN	EXIT	END;
				base := CRM.CodeBase(mod);
				IF (pc >= base) & (pc < base + CRM.CodeSize(mod)) THEN	EXIT	END;
				mod := CRM.NextModule()
			END;
			IF mod # NIL THEN
				CRM.GetModuleName(mod, name);
				Log.Tab; Log.String(name); Log.Char('['); LogHex(pc - base); Log.Char(']')
			END;
		END LogLocation;

	BEGIN
		GetTargetStateAndBreak;
		Done := TRUE; nofVars := 0; c1 := nul;

		mod := CRM.ThisLoadedModule(kernelModName);
		IF mod = NIL THEN
			Error(25)
		ELSE
			referencePos := 0; RefOpen(kernelModName);
			XU.GetRefModel(modName$, refTextModel);
			IF referencePos = 0 THEN	Error(11)	END
		END;
		IF Done THEN
			ReadMemLocs("nofUnexpInt", len, buff); 	nofUnexpInt := buff[0];
			ReadMemLocs("trInd", len, buff); 	trInd := buff[0];
			ReadMemLocs("stAdr", len, buff); 	stAdr := buff[0];
			ReadMemLocs("pcs", len, pcs);
			ReadMemLocs("status", len, status);
			ReadMemLocs("vect", len, vect);
		END;
		IF Done THEN
			Log.String("number of unexpected exceptions: "); Log.Int(nofUnexpInt);
			IF nofUnexpInt > 0 THEN
				Log.String(", trace index: "); Log.Int(trInd); Log.Ln;
				n := MIN(len, nofUnexpInt);
				LogExceptionsHead;
(*	GetTargetState;	*)
				WHILE n > 0 DO
					Log.Tab; Log.Int(nofUnexpInt);
					intVal := vect[trInd]; 	vectNr := intVal MOD 1000H DIV 4;
					Log.Tab; LogHex(intVal DIV 1000H MOD 16); (*format*)
					Log.Tab; Log.Tab; Log.Int(vectNr); (*vectNr*)
					Log.Tab; LogHex(vectNr * 4); (*vector offset*)
					Log.Tab; LogHex(status[trInd]);
					intVal := pcs[trInd]; 	Log.Tab; LogHex(intVal); 	LogLocation(intVal); 	Log.Ln;
					Log.Tab; Log.Tab; Log.Tab;
					IF vectNr < 32 THEN
						Strings.IntToString(vectNr, tempName);
						XE.GetErrorCommentByName(NIL, excPrefix + tempName$, tempName); tempName[0] := ' ';
						Log.String(tempName$);
					END;
					IF vectNr = 7 THEN(*TRAPcc, TRAPV, read mem words frmo pc-6 ... pc*)
						tempName := "";
						mwordsPC[3] := BDI.readMem(intVal - 3 * 2, 2);

						HALT(35);
					(*
					BDI.DumpMem(mwordsPC[2], 2);
					BDI.DumpMem(mwordsPC[1], 2);	BDI.DumpMem(mwordsPC[0], 2);
					*)
						IF mwordsPC[1] = 4E76H THEN (*TRAPV | TRAPcc with extension word of that pattern*)
							tempName := ": TRAPV";
						ELSIF mwordsPC[2] = 50FAH THEN (*TRAPT (HALT(ew))*)
							Strings.IntToString(mwordsPC[1], tempName);
							tempName := ": HALT(" + tempName + ")";
						END;
						Log.String(tempName$)
					END;
					Log.Ln;
					trInd := (trInd - 1) MOD len; 	DEC(nofUnexpInt); 	DEC(n);
				END;
(*	TurnTargetToPrevState; ShowTargetState	*)
				LogDefaultRuler
			END
		END;
		TurnTargetToPrevState; ShowTargetState
	END ShowExceptionHistory; 


	PROCEDURE WriteMem (form: SHORTINT); 
		VAR
			c: CHAR; 	memAddr, memStartAddr, memData: INTEGER; n, itemSize: SHORTINT;
	BEGIN
		n := 0; itemSize := formSizes[form];
		ConnectGlobalScannerToCmdParams; 	IF ~gScnr.done THEN	Error(22); RETURN	END;
		gScnr.SetOpts({XU.soSkipComments, XU.soScanComments, XU.soReturnViews});

		gScnr.Int(memStartAddr); 	IF ~gScnr.done THEN	SyntaxErrorAtScnrPos(gScnr.Pos(), 21); 	RETURN	END;
		gScnr.Char(c);
		IF ~gScnr.done OR (c # ':') THEN	SyntaxErrorAtScnrPos(gScnr.Pos() - 1, 05); 	RETURN	END;

		gScnr.Int(memData); 	IF ~gScnr.done THEN	SyntaxErrorAtScnrPos(gScnr.Pos(), 26); 	RETURN	END;

		GetTargetStateAndBreak;
		Log.Ln; Log.String("writing to memory:"); Log.Ln; LogHex(memStartAddr); Log.Char(':');
		BDI.writeMem(memStartAddr, memData, itemSize); 	OutItem(memData, form);
		memAddr := memStartAddr;

		LOOP
			IF ~BDI.Done THEN EXIT END;
			INC(n, itemSize);
			IF gScnr.Next() = XU.stChar THEN
				gScnr.Char(c);
				IF c = '~' THEN
					Log.String("~"); Log.Ln;
					gScnr.Int(memAddr); 	IF ~gScnr.done THEN	EXIT	END;
					gScnr.Char(c); 	IF ~gScnr.done OR (c # ':') THEN	EXIT	END;
					LogHex(memAddr); Log.Char(':');
				END;
			END;
			gScnr.Int(memData);
			IF gScnr.done THEN
				HALT(35);
			(*
			BDI.FillMem(memData, itemSize); OutItem(memData, form);
			*)
			ELSE
				EXIT
			END;
		END;
		Log.Ln; Log.Int(n); Log.String(" bytes written to memory");
		Log.Tab; LogXo68x32SystemCmd("ReadMem");
		Log.String(itemNames[itemSize]$); Log.Char(' '); LogHex(memStartAddr); Log.String(": ");
		Log.Int(n DIV itemSize); LogCmdrEnd; Log.Ln;
		TurnTargetToPrevState; ShowTargetState
	END WriteMem; 

	PROCEDURE WriteReg * (regName: ARRAY OF CHAR; val: INTEGER; VAR stillOk: BOOLEAN); 
	(* Sets the register defined by regName to val. regName must be member of the register dictionary (module RegDict).
		stillOk := stillOk & operation successful
	*)
		VAR
			found: BOOLEAN;
	BEGIN
		RegDict.SelectReg(regName, found); 	stillOk := stillOk & found;
		IF stillOk THEN
			CASE RegDict.RegType() OF
			| RegDict.UserReg: 	BDI.writeUserReg(RegDict.RegCode(), val)
			| RegDict.SysReg: 	 BDI.writeSysReg(  RegDict.RegCode(), val)
			| RegDict.CtrlReg: 	 BDI.writeMem(  RegDict.RegCode(), val, RegDict.RegSize())
			ELSE
				stillOk := FALSE
			END;
			stillOk := stillOk & BDI.Done
		END
	END WriteReg; 

	PROCEDURE ShowUserRegNames * ; 
	(** Shows the user register names in System.Log.
	*)
		VAR n, m: INTEGER; name: RegDict.RegName;
	BEGIN
		RegDict.SelectFirstReg(); 	Log.Ln; Log.String("user registers:");
		Log.Tab; LogXo68x32SystemCmd("ReadRegister" ); Log.Ln; Log.Tab;
		m := nofRegNamesPerLine;
		FOR n := 0 TO RegDict.nofRegs - 1 DO
			IF RegDict.RegType() = RegDict.UserReg THEN
				IF m = 0 THEN	Log.Ln; Log.Tab; m := nofRegNamesPerLine	END;
				Log.Tab; RegDict.GetRegName(name); Log.String( name$); 	DEC(m)
			END;
			RegDict.SelectNextReg()
		END;
		LogCmdrEnd; Log.Ln
	END ShowUserRegNames; 

	PROCEDURE ShowSysRegNames * ; 
	(** Shows the system register names in System.Log.
	*)
		VAR n, m: INTEGER; name: RegDict.RegName;
	BEGIN
		RegDict.SelectFirstReg(); Log.Ln; Log.String("system registers:");
		Log.Tab; LogXo68x32SystemCmd("ReadRegister" ); Log.Ln; Log.Tab;
		m := nofRegNamesPerLine;
		FOR n := 0 TO RegDict.nofRegs - 1 DO
			IF RegDict.RegType() = RegDict.SysReg THEN
				IF m = 0 THEN	Log.Ln; Log.Tab; 	m := nofRegNamesPerLine	END;
				Log.Tab; RegDict.GetRegName(name); Log.String(name$); 	DEC(m)
			END;
			RegDict.SelectNextReg()
		END;
		LogCmdrEnd; Log.Ln
	END ShowSysRegNames; 

	PROCEDURE ShowCtrlRegNames * ; 
	(** Shows the control register names in System.Log.
	*)
		VAR n, m: INTEGER; name: RegDict.RegName;
	BEGIN
		RegDict.SelectFirstReg(); Log.Ln; Log.String("control registers:");
		Log.Tab; LogXo68x32SystemCmd("ReadRegister" ); Log.Ln; Log.Tab;
		m := nofRegNamesPerLine;
		FOR n := 0 TO RegDict.nofRegs - 1 DO
			IF RegDict.RegType() = RegDict.CtrlReg THEN
				IF m = 0 THEN	Log.Ln; Log.Tab; m := nofRegNamesPerLine	END;
				Log.Tab; RegDict.GetRegName(name); Log.String(name$); 	DEC(m)
			END;
			RegDict.SelectNextReg()
		END;
		LogCmdrEnd; Log.Ln
	END ShowCtrlRegNames; 

	PROCEDURE ShowRegNames * ; 
	(** Shows all register names in System.Log.
	*)
	BEGIN
		Log.Ln; Log.String("Register Dictionary:" );
		Log.String("  (total nr of registers: " ); 	Log.Int(RegDict.nofRegs); 	Log.Ln;
		ShowUserRegNames; 	Log.Ln;
		ShowSysRegNames; 	Log.Ln;
		ShowCtrlRegNames; 	Log.Ln
	END ShowRegNames; 

	PROCEDURE DumpRegDictionary * ; 
	(** Shows the content of the register dictionary (all registers with there attributes) in System.Log.
	*)
		VAR n: INTEGER; name: RegDict.RegName;
	BEGIN
		RegDict.SelectFirstReg(); 	Log.String("Register Dictionary Dump:" ); Log.Ln;
		FOR n := 0 TO RegDict.nofRegs - 1 DO
			IF RegDict.RegType() = RegDict.CtrlReg THEN
				Log.Tab; RegDict.GetRegName(name); Log.String(name$); Log.Char(',');
				Log.Tab; LogHex(RegDict.RegCode());
				Log.String(",   size=" ); Log.Int(RegDict.RegSize());
				Log.String(",   type=" ); Log.Int(RegDict.RegType()); 	Log.Ln;
			END;
			RegDict.SelectNextReg()
		END;
		Log.Ln
	END DumpRegDictionary; 

	PROCEDURE ClearUserRegs * ; 
	(** Clears the user registers of the target processor (loads them with 0).
	*)
		VAR n: INTEGER;
	BEGIN
		RegDict.SelectFirstReg();
		FOR n := 0 TO RegDict.nofRegs - 1 DO
			IF RegDict.RegType() = RegDict.UserReg THEN	BDI.writeUserReg(RegDict.RegCode(), 0)	END;
			RegDict.SelectNextReg()
		END
	END ClearUserRegs; 

	PROCEDURE ReadRegister * ; 
	(** parameters:	regName {regName} "¿¿E".
		Shows the contents of the registers, listed in the parameter list.
	*)
		VAR
			regName: Name; 	validName: BOOLEAN;
			name2: ARRAY 32 OF CHAR;
	BEGIN
		ConnectGlobalScannerToCmdParams; 	IF ~gScnr.done THEN	Error(22); RETURN	END;
		Log.Ln; LogXo68x32SystemCmd("WriteRegister"); Log.Ln;
		gScnr.Ident(name2); regName := SHORT(name2$);
		IF ~gScnr.done THEN	SyntaxErrorAtScnrPos(gScnr.Pos(), 00); 	RETURN	END;

		GetTargetStateAndBreak;
		REPEAT
			WriteRegToLog(regName, validName); 	gScnr.Ident(name2); regName := SHORT(name2$);
		UNTIL ~gScnr.done OR ~validName;
		TurnTargetToPrevState;
		LogCmdrEnd; Log.Ln; ShowTargetState
	END ReadRegister; 

	PROCEDURE WriteRegister * ; 
	(** parameters:	regAssignment {regAssignment} "¿¿E".	regAssignment = regName "=" value.
		Loads the listed registers with the given values.
	*)
		VAR
			regName: Name; 	c: CHAR; 	val: INTEGER; 	validName: BOOLEAN;
			name2: ARRAY 32 OF CHAR;
	BEGIN
		ConnectGlobalScannerToCmdParams; 	IF ~gScnr.done THEN	Error(22); RETURN	END;
		gScnr.SetOpts({XU.soSkipComments, XU.soScanComments, XU.soReturnViews});

		Log.Ln; Log.String("writing to register(s): "); LogXo68x32SystemCmd("ReadRegister"); Log.Ln;
		LOOP
			gScnr.Ident(name2); regName := SHORT(name2$); 	Log.Tab; Log.String(regName$);
			RegDict.SelectReg(regName, validName);
			IF ~gScnr.done OR ~validName THEN	SyntaxErrorAtScnrPos(gScnr.Pos(), 00); EXIT	END;
			gScnr.Char(c);
			IF ~gScnr.done OR (c # '=') THEN	SyntaxErrorAtScnrPos(gScnr.Pos(), 4); EXIT	END;
			gScnr.Int(val);
			IF ~gScnr.done THEN	SyntaxErrorAtScnrPos(gScnr.Pos(), 26); EXIT	END;

			CASE RegDict.RegType() OF
			| RegDict.UserReg: 	BDI.writeUserReg(RegDict.RegCode(), val);
			| RegDict.SysReg: 	 BDI.writeSysReg(  RegDict.RegCode(), val);
			| RegDict.CtrlReg: 	 BDI.writeMem(  RegDict.RegCode(), val, RegDict.RegSize());
			ELSE
				Error(1);
			END;
			IF ~BDI.Done THEN	Error(27); 	EXIT	END;
			IF gScnr.Next() # XU.stIdent THEN	EXIT	END
		END;
		LogCmdrEnd; Log.Ln; ShowTargetState
	END WriteRegister; 

	PROCEDURE ReadMemByte * ; 
	(** parameters:	address ":" n.
		Read n bytes at address and show them in System.Log (n <= 256).
	*)
	BEGIN	ReadMem(sfByte)
	END ReadMemByte; 

	PROCEDURE ReadMemWord * ; 
	(** parameters:	address ":" n.
		Read n words (2 byte locations) at address and show them in System.Log (n <= 256).
		Note: address must be dividable by 2, otherwise it is truncated.
	*)
	BEGIN	ReadMem(sfShInt)
	END ReadMemWord; 

	PROCEDURE ReadMemLong * ; 
	(** parameters:	address ":" n.
		Read n long-words (4 byte locations) at address and show them in System.Log (n <= 256).
		Note: address must be dividable by 4, otherwise it is truncated.
	*)
	BEGIN	ReadMem(sfInt)
	END ReadMemLong; 

	PROCEDURE WriteMemByte * ; 
	(** parameters:	address ":" value {value} "¿¿E".
		Write the list of values to memory, starting at address. The size of each memory location is 1 byte.
	*)
	BEGIN	WriteMem(sfByte)
	END WriteMemByte; 

	PROCEDURE WriteMemWord * ; 
	(** parameters:	address ":" value {value} "¿¿E".
		Write the list of values to memory, starting at address. The size of each memory location is 1 word (2 bytes).
		Note: address must be dividable by 2, otherwise it is truncated.
	*)
	BEGIN	WriteMem(sfShInt)
	END WriteMemWord; 

	PROCEDURE WriteMemLong * ; 
	(** parameters:	address ":" value {value} "¿¿E".
		Write the list of values to memory, starting at address. The size of each memory location is 1 long-word (4 bytes).
		Note: address must be dividable by 4, otherwise it is truncated.
	*)
	BEGIN	WriteMem(sfInt)
	END WriteMemLong; 

	PROCEDURE ResetTarget * ; 
	(** Resets the target board.
	*)
	BEGIN
		BDIMain.ConnectDevice;
		Done := TRUE; firstErr := 0;
		BDI.reset_target;
		IF BDI.Done THEN
			LogLine("Target board reset");
		ELSE
			LogLine("Target board reset failed");
		END
	END ResetTarget; 

	PROCEDURE ResetHost * ; 
	(** Resets the cross system. *)
		VAR n: SHORTINT;
	BEGIN
		Done := TRUE; firstErr := 0;
		IF (Dialog.platform >= Dialog.windows32s) & (Dialog.platform <= Dialog.windows98) THEN
			Fcs := NIL
		ELSE
			Error(51)
		END;
		CRM.Clear;
		LogLine("cross system reset");
		itemNames[0] := "*****"; itemNames[3] := "*****";
		itemNames[1] := "Byte"; 	itemNames[2] := "Word"; 	itemNames[4] := "Long";

	(*OPT Structure Forms (standard types) *)
		FOR n := 0 TO LEN(formSizes) - 1 DO	formSizes[n] := 4	END;
		formSizes[sfUndef] := 1; formSizes[sfSysByte] := 1; formSizes[sfBool] := 1; formSizes[sfShChar] := 1; 
		formSizes[sfByte] := 1;
		formSizes[sfShInt] := 2; 	formSizes[sfReal] := 8; 	formSizes[sfString] := 1;

		SystemConstantsSetUp;
	END ResetHost; 

	PROCEDURE ResetPeripherals * ; 
	(** Assertion of Reset on the target board, synonymous with CPU-RESET instruction (CPU itself is not reset).
	*)
	BEGIN
		BDIMain.ConnectDevice;
		BDI.reset_peripherals; ShowTargetState
	END ResetPeripherals; 


	PROCEDURE GetModName (VAR name: ARRAY OF CHAR); 
	BEGIN
		name := ""; 	IF gScnr.Next() = XU.stIdent THEN	gScnr.Ident(name)	END;
	END GetModName; 

	PROCEDURE GetMemDeviceName (VAR name: ARRAY OF CHAR; VAR end: BOOLEAN); 
		VAR ch: CHAR; 	name2: ARRAY 32 OF CHAR;
	BEGIN
		name[0] := nul; end := FALSE;
		IF gScnr.Next() = XU.stChar THEN
			gScnr.Char(ch);
			IF ch = '~' THEN	end := TRUE
			ELSIF (ch = '/') OR (ch = '\') THEN
				IF gScnr.Next() = XU.stIdent THEN
					gScnr.Ident(name2); name := SHORT(name2$)
				ELSE
					SyntaxErrorAtScnrPos(gScnr.Pos(), 6)
				END;
			ELSE	SyntaxErrorAtScnrPos(gScnr.Pos(), 7)
			END
		END
	END GetMemDeviceName; 

	PROCEDURE LoadModules (kernelMemDeviceId: SHORTINT); 
		VAR
			moduleName, memDeviceName: Name;
			mod, memDeviceId, romDeviceId: INTEGER; 	end: BOOLEAN;
			romBaseDmy, romSizeDmy, ramBaseDmy, ramSizeDmy: INTEGER;
	BEGIN
		Log.Tab; Log.String("loading modules"); Log.Ln;
		CRM.Clear; Services.Collect; 	GetSystemConstants; CRM.Init(maxNofModules);

(*????*)
		romBaseDmy := 0; romSizeDmy := MAX(INTEGER) DIV 2 + 1;
		ramBaseDmy := romSizeDmy; ramSizeDmy := romSizeDmy;
		CRM.InsertMemDevice("RAM", ramBaseDmy, ramSizeDmy, ramSizeDmy, ramSizeDmy, 1, 2, FALSE);
		CRM.InsertMemDevice("ROM", romBaseDmy, romSizeDmy, romSizeDmy, romSizeDmy, 1, 2, TRUE);
		romDeviceId := CRM.MemDeviceId("ROM");
(*
	CRM.InsertTargetMemSegment(romBaseDmy, romSizeDmy, CRM.sgtAttributes, romDeviceId);
	CRM.InsertTargetMemSegment(ramBaseDmy, ramSizeDmy, CRM.sgtAttributes, CRM.ramDeviceId);
*)
		IF kernelMemDeviceId # CRM.ramDeviceId THEN	kernelMemDeviceId := SHORT(romDeviceId)	END;

		CRM.LoadSysMods(kernelMemDeviceId);

		ConnectGlobalScannerToCmdParams;
		gScnr.SetOpts({XU.soSkipComments, XU.soScanComments, XU.soReturnViews});

		LOOP
			GetModName(moduleName);
			IF moduleName = "" THEN	EXIT	END;
			GetMemDeviceName(memDeviceName, end);
			IF memDeviceName = "" THEN
				memDeviceId := CRM.ramDeviceId
			ELSE
				memDeviceId := romDeviceId
			END;
			CRM.LoadTopMod(moduleName, SHORT(memDeviceId));
			IF ~CRM.Done THEN	SyntaxErrorAtScnrPos(gScnr.Pos(), 18); EXIT	END;
			IF end THEN	EXIT	END
		END;
		Done := Done & CRM.Done
	END LoadModules; 

	(*
	PROCEDURE EvaluateCodeVarSize; 
VAR
	moduleName, memDeviceName: Name;
	mod, memDeviceId, romDeviceId: INTEGER;	end: BOOLEAN;
	romBaseDmy, romSizeDmy, ramBaseDmy, ramSizeDmy: INTEGER;
BEGIN
	Log.Tab; Log.String("evaluating code & data size"); Log.Ln;
	CRM.Clear; Services.Collect;	GetSystemConstants; CRM.Init(maxNofModules);
	romBaseDmy := 0; romSizeDmy := MAX(INTEGER) DIV 2 + 1;
	ramBaseDmy := romSizeDmy; ramSizeDmy := romSizeDmy;
	CRM.InsertMemDevice("RAM", ramBaseDmy, ramSizeDmy, ramSizeDmy, ramSizeDmy, 1, 2, FALSE);
	CRM.InsertMemDevice("ROM", romBaseDmy, romSizeDmy, romSizeDmy, romSizeDmy, 1, 2, TRUE);

	romDeviceId := CRM.MemDeviceId("ROM");
	CRM.InsertTargetMemSegment(romBaseDmy, romSizeDmy, CRM.sgtAttributes, romDeviceId);
	CRM.InsertTargetMemSegment(ramBaseDmy, ramSizeDmy, CRM.sgtAttributes, CRM.ramDeviceId);

	IF kernelMemDeviceId # CRM.ramDeviceId THEN	kernelMemDeviceId := SHORT(romDeviceId)	END;

	mod := CRM.ThisMod("TobKernel", kernelMemDeviceId);
	IF mod = -1 THEN  Error(17);	RETURN	END;

	mod := CRM.ThisMod("To68x32Oberon", kernelMemDeviceId);
	IF mod = -1 THEN  Error(17);	RETURN	END;

	ConnectGlobalScannerToCmdParams;
	gScnr.SetOpts({XU.soSkipComments, XU.soScanComments, XU.soReturnViews});

	LOOP
		GetModName(moduleName);
		IF moduleName = "" THEN	EXIT	END;
		GetMemDeviceName(memDeviceName, end);
		IF memDeviceName = "" THEN	memDeviceId := CRM.ramDeviceId	ELSE	memDeviceId := romDeviceId	END;
		mod := CRM.ThisMod(moduleName, SHORT(memDeviceId));
		IF mod = -1 THEN	SyntaxErrorAtScnrPos(gScnr.Pos(), 18); EXIT	END;
		IF end THEN	EXIT	END
	END;
	Done := Done & CRM.Done
END EvaluateCodeVarSize; 

	PROCEDURE SelectModules (kernelMemDeviceId: SHORTINT); 
VAR
	moduleName, memDeviceName: Name;
	mod, memDeviceId: INTEGER;	end: BOOLEAN;
BEGIN
	mod := CRM.ThisMod("TobKernel", kernelMemDeviceId);
	IF mod = -1 THEN  Error(17);	RETURN	END;

	mod := CRM.ThisMod("To68x32Oberon", kernelMemDeviceId);
	IF mod = -1 THEN  Error(17);	RETURN	END;

	ConnectGlobalScannerToCmdParams;
	gScnr.SetOpts({XU.soSkipComments, XU.soScanComments, XU.soReturnViews});

	LOOP
		GetModName(moduleName);
		IF moduleName = "" THEN	EXIT	END;
		GetMemDeviceName(memDeviceName, end);
		IF memDeviceName = "" THEN	memDeviceId := CRM.ramDeviceId
		ELSE	memDeviceId := CRM.MemDeviceId(memDeviceName)
		END;
		IF memDeviceId < 0 THEN	SyntaxErrorAtScnrPos(gScnr.Pos(), 6); EXIT	END;
		mod := CRM.ThisMod(moduleName, SHORT(memDeviceId));
		IF mod = -1 THEN	SyntaxErrorAtScnrPos(gScnr.Pos(), 5); EXIT	END;
		IF end THEN	EXIT	END;
	END;
	Done := Done & CRM.Done
END SelectModules; 

	*)
	PROCEDURE BuildTargetSystem; 
		VAR
			name: Name;
			startAdr, res: INTEGER; 	start: CRM.Command; 	segmAttr: SET;
			memDevId, nofModules: INTEGER; end: BOOLEAN;
	BEGIN
		LogLine("building target system:"); Done := TRUE;
(* check command line syntax and memory device names *)
(*	Oberon.Call("Target.DefineMemory", Oberon.Par, FALSE, res); *)
		Dialog.Call("Xo68x32ImcTarget.DefineMemory", "error calling Xo68x32ImcTarget.DefineMemory", res);
		IF res # 0 THEN Error(31); RETURN	END;
(*
Log.String("Sys200"); Log.Bool(Done); Log.Ln;
*)
		Log.String("XXX"); Log.Ln;
		kernelMemDeviceId := CRM.ramDeviceId; 	anyCodeInRam := FALSE; 	anyCodeInReadOnly := FALSE;
		ConnectGlobalScannerToCmdParams; nofModules := 0;
		LOOP
			IF ~Done THEN	EXIT	END;
			GetModName(name);
			IF name = "" THEN	EXIT	END;
			INC(nofModules);
			GetMemDeviceName(name, end);
			IF end THEN	EXIT	END;
			memDevId := CRM.ramDeviceId;
			IF name # "" THEN	memDevId := CRM.MemDeviceId(name)	END;
			IF memDevId < 0 THEN	SyntaxErrorAtScnrPos(gScnr.Pos(), 6); EXIT	END;
			anyCodeInRam := anyCodeInRam OR (memDevId = CRM.ramDeviceId);
			IF ~anyCodeInReadOnly & (memDevId # CRM.ramDeviceId) THEN
				anyCodeInReadOnly := TRUE; kernelMemDeviceId := SHORT(memDevId)
			END;
		END;
		Done := Done & (nofModules > 0);

		IF Done THEN
			LoadModules(kernelMemDeviceId); 	CRM.EvaluateCodeAndDataSize
		END;

		IF Done THEN
			promCodeSize := CRM.promCodeSize; ramCodeSize := CRM.ramCodeSize;
			romModsVarSize := CRM.romModsVarSize + 4; ramModsVarSize := CRM.ramModsVarSize;

			sysTab[CIcodeSizeRom] := CRM.promCodeSize;
			sysTab[CIcodeSizeRam] := CRM.ramCodeSize;
(*
		CRM.Clear; Services.Collect; CRM.Init(maxNofModules);
*)
			Dialog.Call("Xo68x32ImcTarget.DefineMemory", "error calling Xo68x32ImcTarget.DefineMemory", res);
			IF res # 0 THEN Error(31)	END;
		END;

		IF Done THEN
			IF anyCodeInReadOnly THEN
				CRM.AllocateBlock(sysTabAdr, segmAttr, {CRM.sgtSystemConsts}, kernelMemDeviceId, sysTabSize);
				IF sysTabAdr # CromBase THEN Error(32)	END;
			END;

			CRM.AllocateBlock(sysTabAdr, segmAttr, {CRM.sgtSystemVars}, CRM.ramDeviceId, sysTabSize);
			IF sysTabAdr # CramBase THEN Error(33)	END;

			Log.Tab; Log.String("selecting modules"); Log.Ln;
			CRM.AllocateMemory
(*
		SelectModules(kernelMemDeviceId);
*)
		END;

		IF Done THEN
			Log.Ln; Log.Tab; Log.String("number of modules:"); Log.Tab; Log.Int(CRM.nofModules);
			Log.Ln; Log.Tab; Log.String("size of code in ROMs:"); Log.Tab;
			LogHex(sysTab[CIcodeSizeRom]); Log.Char('='); Log.Int(sysTab[CIcodeSizeRom]);
			Log.Ln; Log.Tab; Log.String("size of code in RAM:"); Log.Tab;
			LogHex(sysTab[CIcodeSizeRam]); Log.Char('='); Log.Int(sysTab[CIcodeSizeRam]);
			Log.String(" bytes"); Log.Ln; Log.Tab; Log.String("size of glob. vars of ROM-modules:"); Log.Tab;
			LogHex(romModsVarSize); Log.Char('='); Log.Int(romModsVarSize);
			Log.String(" bytes"); Log.Ln; Log.Tab; Log.String("size of glob. vars of RAM-modules:"); Log.Tab;
			LogHex(ramModsVarSize); Log.Char('='); Log.Int(ramModsVarSize); Log.String(" bytes");
			Log.Ln;
(*
		kernel := CRM.ThisLoadedModule("TobKernel"); start := 0;
		IF kernel = 0 THEN	start := CRM.ThisCommand(SHORT(kernel), "TargetStart")	END;
		IF start = 0 THEN	Error(34)	END;
*)
			startAdr := CRM.StartAddress();
			INC(VcommandAdr, CRM.VarBase(CRM.kernel))
		END;

		IF Done THEN
			sysTab[CIsupStackOrg] := CramBase + CramSize - safetyZoneSize;
			sysTab[CIstartAdr] := startAdr;
	(*  sysTab[CIsupStackSize] set up by SystemConstantsSetUp *)

			sysTab[CIcodeBaseRom] := CromBase + sysTabSize;
			sysTab[CIcodeBaseRam] := CramBase + sysTabSize + romModsVarSize;

			sysTab[CIramModsVarBase] := sysTab[CIcodeBaseRam] + sysTab[CIcodeSizeRam];
			sysTab[CIramModsVarSize] := ramModsVarSize;
			sysTab[CIsafetyZoneVH] := sysTab[CIramModsVarBase] + ramModsVarSize;

			sysTab[CIheapBase] := sysTab[CIsafetyZoneVH] + safetyZoneSize;

			sysTab[CIsafetyZoneSSTop] := sysTab[CIsupStackOrg];
			sysTab[CIsafetyZoneUSSS] := sysTab[CIsupStackOrg] - sysTab[CIsupStackSize] - safetyZoneSize;
(*	sysTab[CIuserStackSize] set up by SystemConstantsSetUp *)
			sysTab[CIuserStackOrg] := sysTab[CIsafetyZoneUSSS];

			sysTab[CIsafetyZoneHUS] := sysTab[CIuserStackOrg] - sysTab[CIuserStackSize] - safetyZoneSize;
			sysTab[CIheapSize] := sysTab[CIsafetyZoneHUS] - sysTab[CIheapBase];

			sysTab[CInofModules] := CRM.nofModules;
		END;

		IF sysTab[CIheapSize] < 0 THEN	Error(35)	END
	END BuildTargetSystem; 

	PROCEDURE PutModToImageFile (module: CRM.TargetModule); 
		VAR
			blLen, offset, targAdr: INTEGER;
			codeBlock: ARRAY 256 OF INTEGER;
			name: Name;
	BEGIN
		CRM.GetModuleName(module, name);
		configTextForm.WriteTab; configTextForm.WriteString(name$);

(*
	hostAdr := CRM.HostCodeBase(modNr);	   hostEndAdr := hostAdr + CRM.TargConstBlockSize(modNr);
	SYS.PUT(hostEndAdr-4, 55550000H); SYS.PUT(hostEndAdr-2, Fcs(hostAdr, hostEndAdr-2));

	WHILE hostAdr < hostEndAdr DO
		blSize := LEN(codeBlock)*4;
		IF hostEndAdr-hostAdr < blSize THEN	blSize := hostEndAdr-hostAdr	END;
		m := 0; blLen := blSize DIV 4;
		REPEAT
			SYS.GET(hostAdr, highWord); INC(hostAdr, 2); SYS.GET(hostAdr, lowWord); INC(hostAdr, 2);
			codeBlock[m] := ASH(highWord, 16) + lowWord MOD 10000H;	INC(m);
		UNTIL m >= blLen;
		ImFile.WriteDataBlock(targAdr, blLen, codeBlock);
		INC(targAdr, blSize)
	END;
*)
(*
	CRM.PutCodeFcs(modNr);
*)
		targAdr := CRM.ConstBlockBase(module);
		offset := 0;
		REPEAT
			CRM.GetCodeBlock(module, offset, blLen, codeBlock);
			ImFile.WriteDataBlock(targAdr, blLen, codeBlock);
			INC(targAdr, blLen * 4); INC(offset, blLen);
		UNTIL blLen < LEN(codeBlock);

		IF ~ImFile.Done THEN Error(36)	END
	END PutModToImageFile; 


	PROCEDURE Build * ; 
	(** parameters:	moduleName ["/" memDeviceName] {moduleName ["/" memDeviceName]} "¿¿E".
	description:	Resets the target board, selects the modules given by the parameter list and all other modules according to their import lists. It then evaluates the size of code and variables, activates Target.DefineMemory and generates for each memory component an memory image file.
		The memory component RAM is the default component. All code which can be loaded into the target ram is put to file "RAM.Tim".
		The command Xo68x32System.LoadRam loads this image to the target ram and brings the target into the state ready  to go.
	*)
		VAR
			mod: CRM.TargetModule;
			name: Name; targAdr, nofErrorsAtBegin: INTEGER;
			m, n, memDeviceId: INTEGER; 	codeInRam, codeInReadOnly: BOOLEAN;
			memDevice: CRM.MemDevice;
	BEGIN
		Done := TRUE; kernelMemDeviceId := - 1;
		nofErrors := 0; nofErrorsAtBegin := Errors.nofErrors;
		configT := TextModels.dir.New(); configTextForm.ConnectTo(configT);
		XU.Register(configT, NIL, "Tim/" + configText);
	(*
		OutTexts.Open(configT, configHdrText, configText);
		OutTexts.ShowTextInSystemViewer(configT, "^System.Menu.Text");
	Log.String("Sys100"); Log.Ln;
	*)
		BuildTargetSystem;
		IF Done THEN
			Log.Ln; Log.String("Xo68x32System: building starts"); Log.Ln;
			Log.Tab; Log.Int(CRM.nofModules); Log.String(" modules will be linked"); Log.Ln;
			IF CRM.nofModules > maxNofModules THEN	Error(37)	END;

		(* enter mod in system table and log *)
			mod := CRM.FirstModule(); m := 0;
			WHILE mod # NIL DO
				n := CIfirstModule + 3 * m;
				sysTab[n] := CRM.ConstBlockBase(CRM.selectedMod);
				sysTab[n + 1] := sysTab[n] + CRM.TargConstBlockSize(CRM.selectedMod);
				sysTab[n + 2] := CRM.CodeBase(CRM.selectedMod);

				CRM.GetModuleName(CRM.selectedMod, name);
				Log.Ln; Log.String("module "); Log.String(name$); Log.Char(',');
				Log.Tab; Log.String("systemTab[O+"); Log.Int(m);
				memDeviceId := CRM.MemDeviceIdOfMod(CRM.selectedMod);
				CRM.GetMemDevice(memDevice, memDeviceId);
				Log.String("],"); Log.Tab; Log.String("memory device: "); Log.String(memDevice.name$); Log.Ln;

				Log.Tab; Log.String("code:"); Log.Tab; LogHex(sysTab[n]); Log.String(" .. "); LogHex(sysTab[n + 1] - 1);
				Log.Tab; Log.String("size = "); LogHex(CRM.TargConstBlockSize(CRM.selectedMod));
				Log.Char('='); Log.Int(CRM.TargConstBlockSize(CRM.selectedMod));
				Log.Ln; Log.Tab; Log.String("variables:"); Log.Tab; LogHex(CRM.VarBase(CRM.selectedMod));
				Log.String(" .. "); LogHex(CRM.VarBase(CRM.selectedMod) + CRM.VarSize(CRM.selectedMod) - 1);
				Log.Tab; Log.String("size = ");
				LogHex(CRM.VarSize(CRM.selectedMod)); Log.Char('='); Log.Int(CRM.VarSize(CRM.selectedMod));
				Log.Ln; Log.Tab; Log.String("body:"); Log.Tab; LogHex(sysTab[n + 2]);
				Log.Ln;
				INC(m); mod := CRM.NextModule()
			END;

			CRM.SortModsAccToMemDevices;
			codeInRam := FALSE; codeInReadOnly := FALSE;

			mod := CRM.FirstModule(); m := 0;
			WHILE mod # NIL DO
				memDeviceId := CRM.MemDeviceIdOfMod(CRM.selectedMod);
				codeInRam := codeInRam OR (memDeviceId = CRM.ramDeviceId);
				codeInReadOnly := codeInReadOnly OR (memDeviceId # CRM.ramDeviceId);

				CRM.GetMemDevice(memDevice, memDeviceId); name := memDevice.name$;
				ImFile.SetFileName(name); ImFile.OpenWrite(name$, memDeviceId);
				configTextForm.WriteString("ImageFile: " + name$); configTextForm.WriteLn;
				configTextForm.WriteString("Modules:");
				WHILE (CRM.selectedMod # NIL) & (CRM.MemDeviceIdOfMod(CRM.selectedMod) = memDeviceId) DO
					PutModToImageFile(CRM.selectedMod); 	INC(m); mod := CRM.NextModule()
				END;
				configTextForm.WriteLn;
				ImFile.Close;
			END;
			configTextForm.WriteLn; configTextForm.WriteString("END."); configTextForm.WriteLn;
			XU.Register(configT, NIL, "Tim/" + configText);

			sysTab[LEN(sysTab^) - 1] := 55550000H;
		(*
			sysTab[LEN(sysTab^)-1] := 55550000H+LONG(Fcs(SYS.ADR(sysTab),SYS.ADR(sysTab)+sysTabSize-2)) MOD 10000H;
		*)
			systemParDefined := TRUE;

			IF codeInReadOnly THEN	targAdr := CromBase	ELSE	targAdr := CramBase	END;

			CRM.GetMemDeviceName(name, kernelMemDeviceId);
			ImFile.SetFileName(name); ImFile.Append(name$);
			ImFile.WriteDataBlock(targAdr, LEN(sysTab^), sysTab^);
			ImFile.Close;
			Log.Ln; Log.Tab; Log.String("system table put to image file: "); Log.String(name$); Log.Ln;

			IF kernelMemDeviceId # CRM.ramDeviceId THEN
				name := "RAM"; 	ImFile.SetFileName(name); 	ImFile.Append(name$);
				IF ~ImFile.Done THEN	ImFile.OpenWrite(name$, CRM.ramDeviceId)	END;
				ImFile.WriteDataBlock(CramBase, LEN(sysTab^), sysTab^);
				IF ~ImFile.Done THEN	Error(38)	END;
				ImFile.Close;
				Log.Ln; Log.Tab; Log.String("system table put to RAM.Tim");
			END;
		(*	CRM.CollectCodeDataRefBlks; Services.Collect;	*)
		END;
		Log.Ln; Log.Tab; Log.String("system build completed with"); Log.Tab;
		nofErrors := SHORT(Errors.nofErrors - nofErrorsAtBegin);
		Log.Ln; Log.Tab; Log.Int(nofErrors); Log.String("  errors"); Log.Ln; Log.Ln
	END Build; 

	PROCEDURE LoadRam * ; 
(** Preconditions:	the targets Read Only Memory Deviceonents are up to date (click on  Xo68x32System.CheckReadOnlyMem)
		there is an image file RAM.Tim
		if neccessary, click on  Xo68x32System.Build  to update all images
Description:	the image in file  RAM.Tim  is loaded to the target ram.
Postconditions:	the target is ready to go: click on:  Xo68x32System.TargetGo
*)
		VAR
			codeBlock: ARRAY 256 OF INTEGER; name: Name; adr, len: INTEGER;
			res, n, dataLength, recLength, i: INTEGER;
			data: ARRAY MAX_NOF_LONGS_FILL OF INTEGER;
			firstAddrSet: BOOLEAN; index: INTEGER;
	BEGIN
		ResetTarget;
		Dialog.Call("Xo68x32ImcTarget.Init", "error calling Xo68x32ImcTarget.Init", res);
		IF res # 0 THEN Error(39)	END;
		IF ~Done OR ~BDI.Done THEN Error(40); 	RETURN	END;
		Log.Tab; Log.String("controller reset and initialised"); Log.Ln;

		Log.Ln; Log.String("loading of target RAM from file  ");
		name := "RAM";
		ImFile.SetFileName(name); ImFile.OpenRead(name$); Log.String(name$); Log.Ln;
		(*
		Log.String("  starts"); Log.Ln;
		*)

		IF COMPARE_IMAGE THEN
			firstAddrSet := FALSE;
			index := 0;
			FOR i := 0 TO LEN(addrList) - 1 DO
				addrList[i] := 0;
			END
		END;
		REPEAT
		(*
			Log.String("ReadDataBlock..."); Log.Ln;
		*)
			ImFile.ReadDataBlock(adr, len, codeBlock);
			IF COMPARE_IMAGE THEN
				IF ~firstAddrSet THEN
					firstAddrSet := TRUE;
				END;
				FOR i := 0 TO len - 1 DO
					addrList[index + i] := adr + i * 4;
					dataList[index + i] := codeBlock[i]
				END;
			END;
		(*
		FOR i := 0 TO len - 1 DO
			Log.String("addr: "); LogHex(adr + i*4); Log.String(", val: "); LogHex(codeBlock[i]); Log.Ln;
		END;
		*)
			IF len > 0 THEN
		(*
				Log.String("**Setup address: "); LogHex(adr); Log.String(", val: "); LogHex(codeBlock[0]); Log.Ln;
		*)
				BDI.writeMem(adr, codeBlock[0], 4)
			END;
			n := 1;
			WHILE (n < len) & BDI.Done DO
				dataLength := MAX_NOF_LONGS_FILL;
				IF len - n <= MAX_NOF_LONGS_FILL THEN
					dataLength := len - n
				END;
				FOR i := 0 TO dataLength - 1 DO
					data[i] := codeBlock[n + i];
				(*
				Log.String("i: "); Log.Int(i); Log.String(", addr: "); LogHex(adr + n*4 + i*4);
				Log.String(", val: "); LogHex(codeBlock[n + i]); Log.Ln;
				*)
				END;
			(*
			Log.String("Fill: dataLength: "); Log.Int(dataLength);
			Log.String(" n: "); Log.Int(n); Log.String(" len: "); Log.Int(len); Log.Ln;
			*)
				INC(n, dataLength);
				BDI.fillMem(data, dataLength);
			END;
			Log.Char('.');
			index := index + len;
		UNTIL ImFile.eof OR ~ImFile.Done OR ~BDI.Done;
		maxDataListIndex := index;
		Log.Ln;

		ASSERT(ImFile.Done, 99);
		ImFile.Close;

		sysTab[0] := BDI.readMem(CramBase, 4); n := 1;
		REPEAT
			dataLength := MAX_NOF_LONGS_FILL;
			IF LEN(sysTab^) - n < MAX_NOF_LONGS_FILL THEN
				dataLength := LEN(sysTab^) - n
			END;
(* FIXME: LEN(data) may be too long for the last dump *)
			BDI.dumpMem(LEN(data), data, recLength);
		(*
			Log.String("Dump: recLength: "); Log.Int(recLength);
			Log.String(", LEN(sysTab^): "); Log.Int(LEN(sysTab^));
			Log.String(", n: "); Log.Int(n); Log.Ln;
		*)
			FOR i := 0 TO dataLength - 1 DO
				sysTab[n + i] := data[i]
			END;
			INC(n, recLength)
		UNTIL (n >= LEN(sysTab^)) OR ~BDI.Done;

		IF ~Done THEN Error(41)	END;

		WriteReg("SSP", sysTab[CIsupStackOrg], Done); 	WriteReg("USP", sysTab[CIuserStackOrg], Done);
		WriteReg("PCC", sysTab[CIstartAdr], Done); 	WriteReg("RPC", sysTab[CIstartAdr], Done);
		WriteReg("VBR", CramBase, Done);
		IF ~Done THEN Error(42)
		ELSE
			Log.Ln; Log.String("Xo68x32System: ram image successfully loaded"); Log.Ln;
			ShowTargetState
		END
	END LoadRam; 

	(*
	PROCEDURE CheckImage*; 
VAR
	codeBlock: ARRAY 256 OF INTEGER; name: Name;
	adr, romBase, long, len: INTEGER;	n, nofIMFs: SHORTINT; ch: SHORTCHAR; error, cmpOk: BOOLEAN;
BEGIN
	Done := TRUE; nofIMFs := 0; Log.Ln;
	romBase :=  TKernelConst("CromBase");
	In.OpenTextFile("TargetConfig.Text");
	LOOP
		IF ~gScnr.done THEN	Error(43); EXIT	END;
		REPEAT
			IF gScnr.Next() = Utilities.stIdent THEN	gScnr.Ident(name)
			ELSE gScnr.Char(ch)
			END;
		UNTIL ~gScnr.done OR (name="ImageFile:") OR (name="END.");

		IF ~gScnr.done THEN	SyntaxErrorAtScnrPos(gScnr.Pos(), 44); EXIT
		ELSIF name="END." THEN	EXIT	END;

		gScnr.Ident(name);
		IF ~gScnr.done THEN	SyntaxErrorAtScnrPos(gScnr.Pos(), 45); EXIT	END;

		Log.String("checking image file: "); Log.String(name); Log.Ln;
		ImFile.OpenRead(name);
		IF ~ImFile.Done THEN	SyntaxErrorAtScnrPos(gScnr.Pos(), 46); EXIT	END;

		REPEAT
			ImFile.ReadDataBlock(adr, len, codeBlock);
			IF len > 0 THEN	BDI.ReadMem(adr, long, 4)	END;
			n := 0;
			WHILE (n < len) & BDI.Done & (codeBlock[n]=long) DO	INC(n); BDI.DumpMem(long, 4)	END;
			cmpOk := (n = len) & BDI.Done;
			error := ~ImFile.Done OR ~cmpOk;
		UNTIL ~cmpOk OR ImFile.eof OR error;

		IF (n < len) & (adr = romBase) & (len=LEN(sysTab^)) THEN
			Log.String("\nsystem table at  "); LogHex(adr+n*4, 0); Log.String("  has changed (might be ok)\n")
		ELSIF error THEN
			IF ~ImFile.Done THEN	Error(47)
			ELSIF ~BDI.Done THEN	Error(48)
			ELSE
				Error(50);
				Log.String("\n\tat mem loc: "); LogHex(adr+n*4, 0);
				Log.String("\n\tval on target: "); LogHex(long, 0);
				Log.String("\n\tval in file: "); LogHex(codeBlock[n], 0);
				Log.Ln
			END;
			EXIT
		END;
		INC(nofIMFs);
	END;

	IF Done THEN
		IF nofIMFs > 0 THEN	Log.Ln; Log.Int(nofIMFs, 0); Log.String(" image file(s) checked successfully")
		ELSE	Error(49)
		END
	ELSE
		Log.String("checking terminated with errror")
	END;
	Log.Ln
END CheckImage; 

	*)
	PROCEDURE TargetGo * ; 
(** Resumes execution of the target program at RPC
*)
	BEGIN	(* GetTargetState; *) BDI.go; ShowTargetState
	END TargetGo; 

	PROCEDURE TargetBreak * ; 
(** Breaks execution of the target program and enters background debug mode. Click Xo68x32System.TargetGo to carry on.
*)
	BEGIN
		BDI.break_;
		ShowTargetState
	END TargetBreak; 

	PROCEDURE TargetCmd * ; 
(** Activates the command specified by the parameter.
	Expl:	Xo68x32System.TargetCmd TReflect.ChangeDot activates command ChangeDot of module TReflect on target.
*)
		VAR
			mod: CRM.TargetModule; cmd: CRM.Command;
			name: LongName; 	p: INTEGER;
			cmdName: ARRAY 64 OF CHAR;
			name2: ARRAY 32 OF CHAR;
	BEGIN
		GetTargetStateAndBreak;
		ConnectGlobalScannerToCmdParams;
		IF gScnr.done THEN
			gScnr.Ident(name2); name := SHORT(name2$);
			IF ~gScnr.done THEN	RETURN	END;
			Strings.Find(name$, ".", 0, p);
			IF p = 0 THEN	RETURN	END;
			Log.String("target cmd: "); Log.String(name$);
			Strings.Extract(name$, p + 1, LEN(name$) - p - 1, cmdName);
			name[p] := 0X;
			mod := CRM.ThisLoadedModule(name); cmd := 0;
			IF mod # NIL THEN	cmd := CRM.ThisCommand(mod, SHORT(cmdName$))	END;
			IF cmd # 0 THEN
				Log.String("  ["); LogHex(cmd); Log.Char('['); Log.Ln;
				BDI.writeMem(VcommandAdr, cmd, 4);
				TargetGo;
			ELSE
				Log.String("  not found");
			END;
			Log.Ln;
		END;
		TurnTargetToPrevState
	END TargetCmd; 


	(* Execute after LoadRam to compare the Image and the downloaded data from the mc *)
	PROCEDURE CompareImage * ; 
		VAR
			startIndex, i, memData, recLength, oldAddr: INTEGER;
			data: ARRAY MAX_NOF_LONGS_FILL OF INTEGER;
			sameAddress: BOOLEAN;

		PROCEDURE LogListError (pos, addr, dataList, dataMC: INTEGER);
		BEGIN
			Log.String(" at "); Log.Int(pos); Log.String(", addr: "); Log.IntForm(addr, Log.hexadecimal, 8, ' ', FALSE);
			Log.String(", dataList: "); Log.IntForm(dataList, Log.hexadecimal, 8, ' ', FALSE);
			Log.String(", MC: "); Log.IntForm(dataMC, Log.hexadecimal, 8, ' ', FALSE); Log.Ln;
		END LogListError;

	BEGIN
		IF ~COMPARE_IMAGE THEN
			Log.String("set constant COMPARE_IMAGE to TRUE first"); Log.Ln; RETURN;
		END;
		Log.String("CompareImage start"); Log.Ln;
		startIndex := 0;
		WHILE startIndex < maxDataListIndex DO
			memData := BDI.readMem(addrList[startIndex], 4);
			IF memData # dataList[startIndex] THEN
				Log.String("ERROR");
				LogListError(0, addrList[startIndex], dataList[startIndex], memData);
			END;
			BDI.dumpMem(LEN(data), data, recLength);
		(*	Log.String("recLength: "); Log.Int(recLength); Log.Ln;	*)
			i := 1; sameAddress := TRUE; oldAddr := addrList[startIndex + i] - 4;
			WHILE (i <= recLength) & (sameAddress) DO
				IF dataList[startIndex + i] # data[i - 1] THEN
					Log.String("ERROR: ");
					LogListError(startIndex + i, addrList[startIndex + i], dataList[startIndex + i], data[i - 1]);
				END;
			(* Log.String("addrList[startIndex + i] "); Log.Int(addrList[startIndex + i]);
			Log.String(", (oldAddr + 4)"); Log.Int((oldAddr + 4)); Log.Ln; *)
				IF addrList[startIndex + i] # (oldAddr + 4) THEN
					sameAddress := FALSE
				ELSE
					oldAddr := addrList[startIndex + i];
					INC(i);
				END;
			END;
			startIndex := startIndex + i;
		END;
		Log.String("CompareImage done"); Log.Ln;
	END CompareImage; 

BEGIN
	Log.Ln; Log.String(signOnMsg); Log.Ln; 	ResetHost;
END Xo68x32System.
